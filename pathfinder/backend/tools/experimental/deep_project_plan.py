#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# File: deep_project_planner.py
# Author: Wadih Khairallah
# Description: 
#   A tool to convert a high-level project goal into a detailed project plan using
#   advanced prompt engineering techniques. The plan includes a breakdown of tasks,
#   clarifying questions for goal refinement, and actionable steps for AI-assisted execution.
#
# Created: 2025-03-27
# Modified: 2025-03-27

import asyncio
import time
import json
import re
from rich.console import Console
from rich.rule import Rule
from interactor import Interactor

console = Console()

# Global cache for LLM responses to avoid duplicate calls
cache = {}

async def async_interact(llm, prompt, cache_key=None, quiet=False, **kwargs):
    """
    Asynchronous wrapper for llm.interact() using asyncio.to_thread.
    Returns a cached result if available.
    """
    key = cache_key if cache_key is not None else prompt
    if key in cache:
        if not quiet:
            console.print(f"[blue]Using cached result for prompt:[/blue] {key}")
        return cache[key]
    try:
        result = await asyncio.to_thread(llm.interact, prompt, **kwargs)
        cache[key] = result
        return result
    except Exception as e:
        console.print(f"[red]Error during LLM interaction for prompt:[/red] {prompt}\nError: {e}")
        return ""

def parse_sub_tasks(response: str):
    """
    Parse the LLM's response into a list of sub-tasks or questions.
    Enhanced to capture numbered list items as tasks.
    """
    # Attempt to parse JSON first
    try:
        tasks = json.loads(response)
        if isinstance(tasks, list):
            return [str(task).strip() for task in tasks if str(task).strip()]
    except json.JSONDecodeError:
        pass

    # Try to extract tasks using <task> tags
    tag_matches = re.findall(r"<task>(.*?)<\/task>", response, re.IGNORECASE | re.DOTALL)
    if tag_matches:
        return [match.strip() for match in tag_matches if match.strip()]

    # Fallback: extract numbered list items (e.g., "1. Gather e-mail data...")
    numbered_tasks = re.findall(r"^\s*\d+\.\s+(.*)", response, re.MULTILINE)
    if numbered_tasks:
        return [task.strip() for task in numbered_tasks if task.strip()]

    # Further fallback: extract lines that end with a question mark.
    lines = response.splitlines()
    question_lines = [line.strip("- *").strip() for line in lines if line.strip().endswith("?")]
    return question_lines

def assemble_plan(sections):
    """
    Combine plan sections into a final project plan report.
    """
    header = "# Deep Project Plan\n\n"
    body = "\n\n".join(sections)
    footer = "\n\n---\nProject Plan generated by Deep Project Planner Prototype."
    return header + body + footer

async def process_plan_section(llm, section_task):
    """
    Process an individual section of the project plan.
    Steps:
      - Generate a detailed description for the section.
      - Ask for any clarifications that might be needed.
      - Propose actionable steps.
    """
    console.print(f"[green]Processing plan section for:[/green] {section_task}")

    # Step 1: Detailed breakdown
    breakdown_prompt = f"Break down the following project task into detailed steps and explain the rationale behind each step: {section_task}"
    start_time = time.perf_counter()
    breakdown_response = await async_interact(llm, breakdown_prompt, cache_key=f"breakdown:{section_task}", quiet=True)
    breakdown_time = time.perf_counter() - start_time
    console.print(f"[cyan]Breakdown completed in {breakdown_time:.2f} seconds.[/cyan]")

    # Step 2: Clarification prompt - ask if any additional requirements or constraints should be considered.
    clarification_prompt = (
        f"Based on the task '{section_task}', what clarifying questions should be asked to refine the requirements? "
        f"List them as actionable questions."
    )
    start_time = time.perf_counter()
    clarification_response = await async_interact(llm, clarification_prompt, cache_key=f"clarification:{section_task}", quiet=True)
    clarification_time = time.perf_counter() - start_time
    console.print(f"[cyan]Clarification prompt completed in {clarification_time:.2f} seconds.[/cyan]")

    # Step 3: Synthesize the plan section with actionable items.
    synthesis_prompt = (
        f"Using the breakdown and clarifications for '{section_task}', synthesize a project plan section that includes:\n"
        f"- A clear description of the task\n"
        f"- Detailed steps to accomplish it\n"
        f"- Questions to ask for further refinement\n"
        f"- Expected outputs and deliverables\n\n"
        f"Breakdown details:\n{breakdown_response}\n\n"
        f"Clarification questions:\n{clarification_response}"
    )
    start_time = time.perf_counter()
    synthesis_response = await async_interact(llm, synthesis_prompt, cache_key=f"synthesis:{section_task}", quiet=True)
    synthesis_time = time.perf_counter() - start_time
    console.print(f"[cyan]Synthesis completed in {synthesis_time:.2f} seconds.[/cyan]")

    return synthesis_response

async def deep_project_plan(goal):
    """
    Main function that takes a high-level project goal and generates a detailed project plan.
    Steps:
      1. Decompose the goal into sub-tasks.
      2. Process each sub-task to generate plan sections.
      3. Assemble the final project plan.
    """
    # Instantiate our LLM interactor (adjust the model as necessary).
    llm = Interactor(model="ollama:llama3.2")
    
    console.print("[bold]Starting Deep Project Planning...[/bold]")

    # 1. Decompose the goal using advanced prompt techniques.
    planning_prompt = (
        f"Decompose the following project goal into clear, manageable sub-tasks using Chain-of-Thought, "
        f"Tree-of-Thought, and ReAct techniques: {goal}\n"
        f"List each sub-task clearly."
    )
    start_time = time.perf_counter()
    planning_response = await async_interact(llm, planning_prompt, cache_key=f"planning:{goal}", quiet=True)
    planning_time = time.perf_counter() - start_time
    console.print(f"[cyan]Decomposition completed in {planning_time:.2f} seconds.[/cyan]")
    console.print(Rule())

    sub_tasks = parse_sub_tasks(planning_response)
    if not sub_tasks:
        console.print("[red]No sub-tasks were generated. Exiting the planning process.[/red]")
        return ""

    # 2. Process each sub-task concurrently to build the project plan sections.
    tasks = [process_plan_section(llm, task) for task in sub_tasks]
    plan_sections = await asyncio.gather(*tasks)
    console.print(Rule())

    # 3. Compile the final project plan.
    final_plan = assemble_plan(plan_sections)
    return final_plan

if __name__ == "__main__":
    # Example task: create a Python app that processes Gmail messages.
    project_goal = (
        "Create a python app that pulls all my e-mail from a Gmail account, sorts through and prioritizes them, "
        "and provides a well-structured summary of my messages."
    )
    final_plan = asyncio.run(deep_project_plan(project_goal))
    console.print("\n[bold magenta]Final Project Plan:[/bold magenta]\n")
    console.print(final_plan)

