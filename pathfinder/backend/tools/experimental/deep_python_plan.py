#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# File: deep_python_plan.py
# Author: Wadih Khairallah
# Description:
#   A tool to convert a high-level software project goal into a detailed project plan
#   that contains all the technical details needed to generate a complete single-file
#   software solution using LLMs. The output is designed to be directly pasted into an
#   LLM to generate the final software script.
#
# Created: 2025-03-27
# Modified: 2025-03-27

import asyncio
import time
import json
import re
from rich.console import Console
from rich.rule import Rule
from interactor import Interactor

console = Console()

# Global cache for LLM responses to avoid duplicate calls
cache = {}

async def async_interact(llm, prompt, cache_key=None, **kwargs):
    """
    Asynchronous wrapper for llm.interact() using asyncio.to_thread.
    Returns a cached result if available.
    """
    key = cache_key if cache_key is not None else prompt
    if key in cache:
        if not quiet:
            console.print(f"[blue]Using cached result for prompt:[/blue] {key}")
        return cache[key]
    try:
        result = await asyncio.to_thread(llm.interact, prompt, **kwargs)
        cache[key] = result
        return result
    except Exception as e:
        console.print(f"[red]Error during LLM interaction for prompt:[/red] {prompt}\nError: {e}")
        return ""

def parse_sub_tasks(response: str):
    """
    Parse the LLM's response into a list of sub-tasks or questions.
    Enhanced to capture numbered list items as tasks.
    """
    # Attempt to parse JSON first
    try:
        tasks = json.loads(response)
        if isinstance(tasks, list):
            return [str(task).strip() for task in tasks if str(task).strip()]
    except json.JSONDecodeError:
        pass

    # Try to extract tasks using <task> tags
    tag_matches = re.findall(r"<task>(.*?)<\/task>", response, re.IGNORECASE | re.DOTALL)
    if tag_matches:
        return [match.strip() for match in tag_matches if match.strip()]

    # Fallback: extract numbered list items (e.g., "1. Initialize project environment...")
    numbered_tasks = re.findall(r"^\s*\d+\.\s+(.*)", response, re.MULTILINE)
    if numbered_tasks:
        return [task.strip() for task in numbered_tasks if task.strip()]

    # Further fallback: extract lines ending with a question mark.
    lines = response.splitlines()
    question_lines = [line.strip("- *").strip() for line in lines if line.strip().endswith("?")]
    return question_lines

def assemble_plan(sections):
    """
    Combine plan sections into a final project plan report.
    """
    header = "# Deep Software Project Plan\n\n"
    body = "\n\n".join(sections)
    footer = ("\n\n---\nProject Plan generated by Deep Software Project Planner Prototype.\n"
              "Note: The final software must be implemented as a single-file script containing all classes, "
              "functions, and dependencies (aside from installed libraries).")
    return header + body + footer

async def process_plan_section(llm, section_task):
    """
    Process an individual section of the software project plan.
    Steps:
      - Generate a detailed technical breakdown.
      - Ask for clarifying questions or constraints specific to a software solution.
      - Propose actionable steps and architectural design details.
    """
    console.print(f"[green]Processing plan section for:[/green] {section_task}")

    # Step 1: Detailed technical breakdown
    breakdown_prompt = (
        f"Break down the following software project task into detailed technical steps and explain the rationale behind each step. "
        f"Focus on generating a complete single-file solution: {section_task}"
    )
    start_time = time.perf_counter()
    breakdown_response = await async_interact(llm, breakdown_prompt, cache_key=f"breakdown:{section_task}", quiet=True)
    breakdown_time = time.perf_counter() - start_time
    console.print(f"[cyan]Technical breakdown completed in {breakdown_time:.2f} seconds.[/cyan]")

    # Step 2: Clarification prompt - determine constraints and requirements for a single-file implementation.
    clarification_prompt = (
        f"Based on the task '{section_task}', what clarifying questions and constraints should be considered to ensure "
        f"the software can be implemented in a single file? List them as actionable questions."
    )
    start_time = time.perf_counter()
    clarification_response = await async_interact(llm, clarification_prompt, cache_key=f"clarification:{section_task}", quiet=True)
    clarification_time = time.perf_counter() - start_time
    console.print(f"[cyan]Clarification prompt completed in {clarification_time:.2f} seconds.[/cyan]")

    # Step 3: Synthesize the plan section with technical details.
    synthesis_prompt = (
        f"Using the technical breakdown and clarifications for '{section_task}', synthesize a software project plan section "
        f"that includes:\n"
        f"- A clear technical description of the task\n"
        f"- Detailed steps to implement it in a single file\n"
        f"- Required classes, functions, libraries, and error handling measures\n"
        f"- Clarifying questions and constraints for ensuring a complete single-file solution\n"
        f"- Expected outputs and deliverables\n\n"
        f"Breakdown details:\n{breakdown_response}\n\n"
        f"Clarification questions:\n{clarification_response}"
    )
    start_time = time.perf_counter()
    synthesis_response = await async_interact(llm, synthesis_prompt, cache_key=f"synthesis:{section_task}", quiet=True)
    synthesis_time = time.perf_counter() - start_time
    console.print(f"[cyan]Synthesis completed in {synthesis_time:.2f} seconds.[/cyan]")

    return synthesis_response

async def deep_software_project_plan(goal):
    """
    Main function that takes a high-level software project goal and generates a detailed project plan
    that includes all technical details necessary to implement the software as a single-file script.
    Steps:
      1. Decompose the goal into sub-tasks.
      2. Process each sub-task to generate technical plan sections.
      3. Assemble the final project plan.
    """
    # Instantiate our LLM interactor (adjust the model as necessary).
    llm = Interactor(model="ollama:mistral-nemo")

    console.print("[bold]Starting Deep Software Project Planning...[/bold]")

    # 1. Decompose the goal using advanced prompt techniques.
    planning_prompt = (
        f"Decompose the following software project goal into clear, manageable sub-tasks using Chain-of-Thought, "
        f"Tree-of-Thought, and ReAct techniques. Ensure that each sub-task contributes to a complete single-file solution "
        f"(all code must reside in one file). Goal: {goal}\n"
        f"List each sub-task clearly."
    )
    start_time = time.perf_counter()
    planning_response = await async_interact(llm, planning_prompt, cache_key=f"planning:{goal}", quiet=True)
    planning_time = time.perf_counter() - start_time
    console.print(f"[cyan]Decomposition completed in {planning_time:.2f} seconds.[/cyan]")
    console.print(Rule())

    sub_tasks = parse_sub_tasks(planning_response)
    if not sub_tasks:
        console.print("[red]No sub-tasks were generated. Exiting the planning process.[/red]")
        return ""

    # 2. Process each sub-task concurrently to build the software project plan sections.
    tasks = [process_plan_section(llm, task) for task in sub_tasks]
    plan_sections = await asyncio.gather(*tasks)
    console.print(Rule())

    # 3. Compile the final project plan.
    final_plan = assemble_plan(plan_sections)
    return final_plan

if __name__ == "__main__":
    project_goal = (
            "Create a cli based chatbot program using prompt_toolkit and rich python modules that is aethetically pleasing and easy to use.  It should be a robust framwork for adding / commands and other tooling such as plugable agents. This should be self contained as a single file python script."
    )
    final_plan = asyncio.run(deep_software_project_plan(project_goal))
    console.print("\n[bold magenta]Final Software Project Plan:[/bold magenta]\n")
    console.print(final_plan)

